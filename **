:symbolic_algebra>cd ../..
:symbolic-algebra>lein run
No :main namespace specified in project.clj.
:symbolic-algebra>lein repl
nREPL server started on port 56767 on host 127.0.0.1 - nrepl://127.0.0.1:56767
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_91-b14
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=> (make Real 1)

CompilerException java.lang.RuntimeException: Unable to resolve symbol: make in this context, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init2518368425217755798.clj:1:1) 
user=> (require 'symbolic-algebra.core)

CompilerException java.lang.RuntimeException: Too many arguments to if, compiling:(symbolic_algebra/core.clj:58:59) 
user=> (require 'symbolic-algebra.core)
nil
user=> (make Real 1)

user=> CompilerException java.lang.RuntimeException: Unable to resolve symbol: make in this context, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init2518368425217755798.clj:1:1) 


user=>exit
Bye for now!
:symbolic-algebra>lein run
No :main namespace specified in project.clj.
:symbolic-algebra>lein repl
nREPL server started on port 56790 on host 127.0.0.1 - nrepl://127.0.0.1:56790
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_91-b14
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=> (require 'symbolic-algebra.core)

user=> CompilerException java.lang.RuntimeException: Unmatched delimiter: ), compiling:(symbolic_algebra/core.clj:62:18) 
exit
Bye for now!
:symbolic-algebra>lein run
No :main namespace specified in project.clj.
:symbolic-algebra>lein repl
nREPL server started on port 56815 on host 127.0.0.1 - nrepl://127.0.0.1:56815
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_91-b14
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=> (require 'symbolic-algebra.core)

user=> CompilerException java.lang.RuntimeException: EOF while reading, starting at line 107, compiling:(symbolic_algebra/core.clj:267:1)  

user=> (require 'symbolic-algebra.core)
nil
user=> (require 'symbolic-algebra.core)
nil
user=> (make Rational 1 2)

CompilerException java.lang.RuntimeException: Unable to resolve symbol: make in this context, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init8308818252230852698.clj:1:1) 
user=> (add 1 2)

user=> CompilerException java.lang.RuntimeException: Unable to resolve symbol: add in this context, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init8308818252230852698.clj:1:1) 


user=> exit
Bye for now!
:symbolic-algebra>lein run
No :main namespace specified in project.clj.
:symbolic-algebra>lein repl
nREPL server started on port 56941 on host 127.0.0.1 - nrepl://127.0.0.1:56941
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_91-b14
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=> (require 'symbolic-algebra.core)

user=> CompilerException java.lang.RuntimeException: EOF while reading, starting at line 107, compiling:(symbolic_algebra/core.clj:267:1) 


user=> (require 'symbolic-algebra.core)
nil
user=> 

user=> 

user=> (require 'symbolic-algebra.core)
nil
user=> exit
Bye for now!
:symbolic-algebra>lein repl
nREPL server started on port 56951 on host 127.0.0.1 - nrepl://127.0.0.1:56951
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_91-b14
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=> (require 'symbolic-algebra.core)
nil
user=> (make Real 1)

user=> CompilerException java.lang.RuntimeException: Unable to resolve symbol: make in this context, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init2179914095831049567.clj:1:1) 


user=> exit
Bye for now!
:symbolic-algebra>lein run
Exception in thread "main" java.lang.ClassCastException: clojure.lang.ArraySeq cannot be cast to java.lang.Number, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init6691276857696701050.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.ClassCastException: clojure.lang.ArraySeq cannot be cast to java.lang.Number
	at clojure.lang.Numbers.isZero(Numbers.java:92)
	at symbolic_algebra.core$gcd.invokeStatic(core.clj:5)
	at symbolic_algebra.core$gcd.invoke(core.clj:4)
	at symbolic_algebra.core$make_rat.invokeStatic(core.clj:26)
	at symbolic_algebra.core$make_rat.invoke(core.clj:25)
	at symbolic_algebra.core$eval99$fn__100.doInvoke(core.clj:29)
	at clojure.lang.RestFn.invoke(RestFn.java:439)
	at clojure.lang.MultiFn.invoke(MultiFn.java:238)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:180)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init6691276857696701050.clj:1)
	at user$eval5.invoke(form-init6691276857696701050.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: (symbolic_algebra.core.Rational 1 2), compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init1105849128837232832.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: (symbolic_algebra.core.Rational 1 2)
	at clojure.lang.MultiFn.getFn(MultiFn.java:156)
	at clojure.lang.MultiFn.invoke(MultiFn.java:238)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:180)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init1105849128837232832.clj:1)
	at user$eval5.invoke(form-init1105849128837232832.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: clojure.lang.ArraySeq, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init4385300090177591397.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: clojure.lang.ArraySeq
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval134$fn__148$G__117__155.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init4385300090177591397.clj:1)
	at user$eval5.invoke(form-init4385300090177591397.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init7610374314929768181.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval134$fn__148$G__117__155.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init7610374314929768181.clj:1)
	at user$eval5.invoke(form-init7610374314929768181.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run 
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init5248385933270570418.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval134$fn__148$G__117__155.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init5248385933270570418.clj:1)
	at user$eval5.invoke(form-init5248385933270570418.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.ClassCastException: clojure.lang.ArraySeq cannot be cast to java.lang.Number, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init8459097648331260491.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.ClassCastException: clojure.lang.ArraySeq cannot be cast to java.lang.Number
	at clojure.lang.Numbers.isZero(Numbers.java:92)
	at symbolic_algebra.core$gcd.invokeStatic(core.clj:5)
	at symbolic_algebra.core$gcd.invoke(core.clj:4)
	at symbolic_algebra.core$make_rat.invokeStatic(core.clj:26)
	at symbolic_algebra.core$make_rat.invoke(core.clj:25)
	at symbolic_algebra.core$eval99$fn__100.doInvoke(core.clj:29)
	at clojure.lang.RestFn.invoke(RestFn.java:439)
	at clojure.lang.MultiFn.invoke(MultiFn.java:238)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:180)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init8459097648331260491.clj:1)
	at user$eval5.invoke(form-init8459097648331260491.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.ClassCastException: clojure.lang.ArraySeq cannot be cast to java.lang.Number, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init7619408310215325239.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.ClassCastException: clojure.lang.ArraySeq cannot be cast to java.lang.Number
	at clojure.lang.Numbers.isZero(Numbers.java:92)
	at symbolic_algebra.core$gcd.invokeStatic(core.clj:5)
	at symbolic_algebra.core$gcd.invoke(core.clj:4)
	at symbolic_algebra.core$make_rat.invokeStatic(core.clj:26)
	at symbolic_algebra.core$make_rat.invoke(core.clj:25)
	at symbolic_algebra.core$eval99$fn__100.doInvoke(core.clj:29)
	at clojure.lang.RestFn.invoke(RestFn.java:439)
	at clojure.lang.MultiFn.invoke(MultiFn.java:238)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init7619408310215325239.clj:1)
	at user$eval5.invoke(form-init7619408310215325239.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" clojure.lang.ArityException: Wrong number of args (1) passed to: core/make-rat, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init6436447852401547462.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: clojure.lang.ArityException: Wrong number of args (1) passed to: core/make-rat
	at clojure.lang.AFn.throwArity(AFn.java:429)
	at clojure.lang.AFn.invoke(AFn.java:32)
	at symbolic_algebra.core$eval99$fn__100.doInvoke(core.clj:29)
	at clojure.lang.RestFn.invoke(RestFn.java:439)
	at clojure.lang.MultiFn.invoke(MultiFn.java:238)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init6436447852401547462.clj:1)
	at user$eval5.invoke(form-init6436447852401547462.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.ClassCastException: clojure.lang.ArraySeq cannot be cast to java.lang.Number, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init7131423412043731993.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.ClassCastException: clojure.lang.ArraySeq cannot be cast to java.lang.Number
	at clojure.lang.Numbers.isZero(Numbers.java:92)
	at symbolic_algebra.core$gcd.invokeStatic(core.clj:5)
	at symbolic_algebra.core$gcd.invoke(core.clj:4)
	at symbolic_algebra.core$make_rat.invokeStatic(core.clj:26)
	at symbolic_algebra.core$make_rat.invoke(core.clj:25)
	at symbolic_algebra.core$eval99$fn__100.doInvoke(core.clj:29)
	at clojure.lang.RestFn.invoke(RestFn.java:439)
	at clojure.lang.MultiFn.invoke(MultiFn.java:238)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init7131423412043731993.clj:1)
	at user$eval5.invoke(form-init7131423412043731993.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.Number, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init9124546220326190483.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.Number
	at clojure.lang.Numbers.remainder(Numbers.java:173)
	at clojure.core$mod.invokeStatic(core.clj:3469)
	at clojure.core$mod.invoke(core.clj:3464)
	at symbolic_algebra.core$gcd.invokeStatic(core.clj:7)
	at symbolic_algebra.core$gcd.invoke(core.clj:4)
	at symbolic_algebra.core$make_rat.invokeStatic(core.clj:26)
	at symbolic_algebra.core$make_rat.invoke(core.clj:25)
	at symbolic_algebra.core$eval99$fn__100.doInvoke(core.clj:29)
	at clojure.lang.RestFn.invoke(RestFn.java:439)
	at clojure.lang.MultiFn.invoke(MultiFn.java:238)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init9124546220326190483.clj:1)
	at user$eval5.invoke(form-init9124546220326190483.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.Number, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init4033116235317247643.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.Number
	at clojure.lang.Numbers.remainder(Numbers.java:173)
	at clojure.core$mod.invokeStatic(core.clj:3469)
	at clojure.core$mod.invoke(core.clj:3464)
	at symbolic_algebra.core$gcd.invokeStatic(core.clj:7)
	at symbolic_algebra.core$gcd.invoke(core.clj:4)
	at symbolic_algebra.core$make_rat.invokeStatic(core.clj:26)
	at symbolic_algebra.core$make_rat.invoke(core.clj:25)
	at symbolic_algebra.core$eval99$fn__100.doInvoke(core.clj:29)
	at clojure.lang.RestFn.invoke(RestFn.java:439)
	at clojure.lang.MultiFn.invoke(MultiFn.java:238)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init4033116235317247643.clj:1)
	at user$eval5.invoke(form-init4033116235317247643.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init9072683583617396283.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval134$fn__148$G__117__155.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init9072683583617396283.clj:1)
	at user$eval5.invoke(form-init9072683583617396283.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: EOF while reading, starting at line 84, compiling:(symbolic_algebra/core.clj:272:1)
	at clojure.lang.Compiler.load(Compiler.java:7386)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init8100262636850143421.clj:1)
	at user$eval5.invokeStatic(form-init8100262636850143421.clj:1)
	at user$eval5.invoke(form-init8100262636850143421.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: EOF while reading, starting at line 84
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1206)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.read(LispReader.java:196)
	at clojure.lang.Compiler.load(Compiler.java:7374)
	... 42 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init1128060609676228588.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval134$fn__148$G__117__155.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init1128060609676228588.clj:1)
	at user$eval5.invoke(form-init1128060609676228588.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: EOF while reading, starting at line 84, compiling:(symbolic_algebra/core.clj:272:1)
	at clojure.lang.Compiler.load(Compiler.java:7386)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init449038361794996746.clj:1)
	at user$eval5.invokeStatic(form-init449038361794996746.clj:1)
	at user$eval5.invoke(form-init449038361794996746.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: EOF while reading, starting at line 84
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1206)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.read(LispReader.java:196)
	at clojure.lang.Compiler.load(Compiler.java:7374)
	... 42 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: EOF while reading, starting at line 84, compiling:(symbolic_algebra/core.clj:272:1)
	at clojure.lang.Compiler.load(Compiler.java:7386)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init6669493704132526289.clj:1)
	at user$eval5.invokeStatic(form-init6669493704132526289.clj:1)
	at user$eval5.invoke(form-init6669493704132526289.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: EOF while reading, starting at line 84
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1206)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.read(LispReader.java:196)
	at clojure.lang.Compiler.load(Compiler.java:7374)
	... 42 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init754603063876536309.clj:1:124)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init754603063876536309.clj:1)
	at user$eval5.invoke(form-init754603063876536309.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init879907366894897717.clj:1:124)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Long
	at clojure.lang.RT.seqFrom(RT.java:542)
	at clojure.lang.RT.seq(RT.java:523)
	at clojure.lang.RT.cons(RT.java:662)
	at clojure.core$cons__4331.invokeStatic(core.clj:29)
	at clojure.core$cons__4331.invoke(core.clj:29)
	at symbolic_algebra.core$make_from_real_imag.invokeStatic(core.clj:33)
	at symbolic_algebra.core$make_from_real_imag.invoke(core.clj:32)
	at symbolic_algebra.core$eval129$fn__130.doInvoke(core.clj:43)
	at clojure.lang.RestFn.invoke(RestFn.java:439)
	at clojure.lang.MultiFn.invoke(MultiFn.java:238)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init879907366894897717.clj:1)
	at user$eval5.invoke(form-init879907366894897717.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init2659747144079871671.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init2659747144079871671.clj:1)
	at user$eval5.invoke(form-init2659747144079871671.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init7091833527129845153.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init7091833527129845153.clj:1)
	at user$eval5.invoke(form-init7091833527129845153.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unable to resolve symbol: Real in this context, compiling:(symbolic_algebra/core.clj:13:1)
	at clojure.lang.Compiler.analyze(Compiler.java:6688)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$HostExpr$Parser.parse(Compiler.java:1009)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.eval(Compiler.java:6924)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init7195032162297077132.clj:1)
	at user$eval5.invokeStatic(form-init7195032162297077132.clj:1)
	at user$eval5.invoke(form-init7195032162297077132.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unable to resolve symbol: Real in this context
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.resolveIn(Compiler.java:7164)
	at clojure.lang.Compiler.resolve(Compiler.java:7108)
	at clojure.lang.Compiler.analyzeSymbol(Compiler.java:7069)
	at clojure.lang.Compiler.analyze(Compiler.java:6648)
	... 54 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unable to resolve symbol: Real in this context, compiling:(symbolic_algebra/core.clj:9:1)
	at clojure.lang.Compiler.analyze(Compiler.java:6688)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$VectorExpr.parse(Compiler.java:3228)
	at clojure.lang.Compiler.analyze(Compiler.java:6671)
	at clojure.lang.Compiler.access$300(Compiler.java:38)
	at clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:589)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler.eval(Compiler.java:6931)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init5715796521902554644.clj:1)
	at user$eval5.invokeStatic(form-init5715796521902554644.clj:1)
	at user$eval5.invoke(form-init5715796521902554644.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unable to resolve symbol: Real in this context
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.resolveIn(Compiler.java:7164)
	at clojure.lang.Compiler.resolve(Compiler.java:7108)
	at clojure.lang.Compiler.analyzeSymbol(Compiler.java:7069)
	at clojure.lang.Compiler.analyze(Compiler.java:6648)
	... 52 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init2281882264134939904.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init2281882264134939904.clj:1)
	at user$eval5.invoke(form-init2281882264134939904.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: class java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init3655400805536533757.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: class java.lang.Class
	at clojure.lang.MultiFn.getFn(MultiFn.java:156)
	at clojure.lang.MultiFn.invoke(MultiFn.java:233)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init3655400805536533757.clj:1)
	at user$eval5.invoke(form-init3655400805536533757.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init4904307550744151090.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init4904307550744151090.clj:1)
	at user$eval5.invoke(form-init4904307550744151090.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init4180033483897224803.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init4180033483897224803.clj:1)
	at user$eval5.invoke(form-init4180033483897224803.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init6559588583116620969.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init6559588583116620969.clj:1)
	at user$eval5.invoke(form-init6559588583116620969.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unable to resolve symbol: reduce-type in this context, compiling:(symbolic_algebra/core.clj:111:7)
	at clojure.lang.Compiler.analyze(Compiler.java:6688)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3766)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$IfExpr$Parser.parse(Compiler.java:2797)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6856)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$MapExpr.parse(Compiler.java:3072)
	at clojure.lang.Compiler.analyze(Compiler.java:6677)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.eval(Compiler.java:6924)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init581590279541499553.clj:1)
	at user$eval5.invokeStatic(form-init581590279541499553.clj:1)
	at user$eval5.invoke(form-init581590279541499553.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unable to resolve symbol: reduce-type in this context
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.resolveIn(Compiler.java:7164)
	at clojure.lang.Compiler.resolve(Compiler.java:7108)
	at clojure.lang.Compiler.analyzeSymbol(Compiler.java:7069)
	at clojure.lang.Compiler.analyze(Compiler.java:6648)
	... 73 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init5016220711199646384.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval151$fn__165$G__134__172.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init5016220711199646384.clj:1)
	at user$eval5.invoke(form-init5016220711199646384.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init3975406396393851292.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init3975406396393851292.clj:1)
	at user$eval5.invoke(form-init3975406396393851292.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init6731611701126953455.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init6731611701126953455.clj:1)
	at user$eval5.invoke(form-init6731611701126953455.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init4498608937759499974.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init4498608937759499974.clj:1)
	at user$eval5.invoke(form-init4498608937759499974.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init4920158418988672885.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init4920158418988672885.clj:1)
	at user$eval5.invoke(form-init4920158418988672885.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init2547227027682816353.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init2547227027682816353.clj:1)
	at user$eval5.invoke(form-init2547227027682816353.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unable to resolve symbol: Ration in this context, compiling:(symbolic_algebra/core.clj:179:5)
	at clojure.lang.Compiler.analyze(Compiler.java:6688)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6856)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.access$300(Compiler.java:38)
	at clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:589)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler.eval(Compiler.java:6931)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init7732924631519491373.clj:1)
	at user$eval5.invokeStatic(form-init7732924631519491373.clj:1)
	at user$eval5.invoke(form-init7732924631519491373.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unable to resolve symbol: Ration in this context
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.resolveIn(Compiler.java:7164)
	at clojure.lang.Compiler.resolve(Compiler.java:7108)
	at clojure.lang.Compiler.analyzeSymbol(Compiler.java:7069)
	at clojure.lang.Compiler.analyze(Compiler.java:6648)
	... 69 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.Number, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init1984448068649925742.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.Number
	at clojure.lang.Numbers.remainder(Numbers.java:173)
	at clojure.core$mod.invokeStatic(core.clj:3469)
	at clojure.core$mod.invoke(core.clj:3464)
	at symbolic_algebra.core$gcd.invokeStatic(core.clj:7)
	at symbolic_algebra.core$gcd.invoke(core.clj:4)
	at symbolic_algebra.core$make_rat.invokeStatic(core.clj:26)
	at symbolic_algebra.core$make_rat.invoke(core.clj:25)
	at symbolic_algebra.core$eval119$fn__120.doInvoke(core.clj:29)
	at clojure.lang.RestFn.invoke(RestFn.java:439)
	at clojure.lang.MultiFn.invoke(MultiFn.java:238)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init1984448068649925742.clj:1)
	at user$eval5.invoke(form-init1984448068649925742.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init2306729108075824542.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init2306729108075824542.clj:1)
	at user$eval5.invoke(form-init2306729108075824542.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unable to resolve symbol: coeff in this context, compiling:(symbolic_algebra/core.clj:200:14)
	at clojure.lang.Compiler.analyze(Compiler.java:6688)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3766)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$HostExpr$Parser.parse(Compiler.java:1009)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6863)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$IfExpr$Parser.parse(Compiler.java:2792)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6856)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.access$300(Compiler.java:38)
	at clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:589)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler.eval(Compiler.java:6931)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init3489391880777542538.clj:1)
	at user$eval5.invokeStatic(form-init3489391880777542538.clj:1)
	at user$eval5.invoke(form-init3489391880777542538.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unable to resolve symbol: coeff in this context
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.resolveIn(Compiler.java:7164)
	at clojure.lang.Compiler.resolve(Compiler.java:7108)
	at clojure.lang.Compiler.analyzeSymbol(Compiler.java:7069)
	at clojure.lang.Compiler.analyze(Compiler.java:6648)
	... 72 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unmatched delimiter: ), compiling:(symbolic_algebra/core.clj:204:29)
	at clojure.lang.Compiler.load(Compiler.java:7386)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init378983570046759540.clj:1)
	at user$eval5.invokeStatic(form-init378983570046759540.clj:1)
	at user$eval5.invoke(form-init378983570046759540.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unmatched delimiter: )
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.LispReader$UnmatchedDelimiterReader.invoke(LispReader.java:1176)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$VectorReader.invoke(LispReader.java:1150)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.read(LispReader.java:196)
	at clojure.lang.Compiler.load(Compiler.java:7374)
	... 42 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unmatched delimiter: ), compiling:(symbolic_algebra/core.clj:208:29)
	at clojure.lang.Compiler.load(Compiler.java:7386)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init110338555441883335.clj:1)
	at user$eval5.invokeStatic(form-init110338555441883335.clj:1)
	at user$eval5.invoke(form-init110338555441883335.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unmatched delimiter: )
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.LispReader$UnmatchedDelimiterReader.invoke(LispReader.java:1176)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$VectorReader.invoke(LispReader.java:1150)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.read(LispReader.java:196)
	at clojure.lang.Compiler.load(Compiler.java:7374)
	... 42 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unable to resolve symbol: mul-term-by-all-terms in this context, compiling:(symbolic_algebra/core.clj:235:18)
	at clojure.lang.Compiler.analyze(Compiler.java:6688)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3766)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$IfExpr$Parser.parse(Compiler.java:2805)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6856)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.access$300(Compiler.java:38)
	at clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:589)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler.eval(Compiler.java:6931)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init2878119809744398571.clj:1)
	at user$eval5.invokeStatic(form-init2878119809744398571.clj:1)
	at user$eval5.invoke(form-init2878119809744398571.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unable to resolve symbol: mul-term-by-all-terms in this context
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.resolveIn(Compiler.java:7164)
	at clojure.lang.Compiler.resolve(Compiler.java:7108)
	at clojure.lang.Compiler.analyzeSymbol(Compiler.java:7069)
	at clojure.lang.Compiler.analyze(Compiler.java:6648)
	... 69 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unable to resolve symbol: p1 in this context, compiling:(symbolic_algebra/core.clj:250:25)
	at clojure.lang.Compiler.analyze(Compiler.java:6688)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$IfExpr$Parser.parse(Compiler.java:2792)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6856)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$MapExpr.parse(Compiler.java:3072)
	at clojure.lang.Compiler.analyze(Compiler.java:6677)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.eval(Compiler.java:6924)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init5215288284941154407.clj:1)
	at user$eval5.invokeStatic(form-init5215288284941154407.clj:1)
	at user$eval5.invoke(form-init5215288284941154407.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unable to resolve symbol: p1 in this context
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.resolveIn(Compiler.java:7164)
	at clojure.lang.Compiler.resolve(Compiler.java:7108)
	at clojure.lang.Compiler.analyzeSymbol(Compiler.java:7069)
	at clojure.lang.Compiler.analyze(Compiler.java:6648)
	... 77 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unable to resolve symbol: p2 in this context, compiling:(symbolic_algebra/core.clj:250:38)
	at clojure.lang.Compiler.analyze(Compiler.java:6688)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$IfExpr$Parser.parse(Compiler.java:2792)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6856)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$MapExpr.parse(Compiler.java:3072)
	at clojure.lang.Compiler.analyze(Compiler.java:6677)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.eval(Compiler.java:6924)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init6112645151664326364.clj:1)
	at user$eval5.invokeStatic(form-init6112645151664326364.clj:1)
	at user$eval5.invoke(form-init6112645151664326364.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unable to resolve symbol: p2 in this context
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.resolveIn(Compiler.java:7164)
	at clojure.lang.Compiler.resolve(Compiler.java:7108)
	at clojure.lang.Compiler.analyzeSymbol(Compiler.java:7069)
	at clojure.lang.Compiler.analyze(Compiler.java:6648)
	... 77 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unable to resolve symbol: error in this context, compiling:(symbolic_algebra/core.clj:254:7)
	at clojure.lang.Compiler.analyze(Compiler.java:6688)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3766)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$IfExpr$Parser.parse(Compiler.java:2805)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6856)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$MapExpr.parse(Compiler.java:3072)
	at clojure.lang.Compiler.analyze(Compiler.java:6677)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.eval(Compiler.java:6924)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init6188456576730631251.clj:1)
	at user$eval5.invokeStatic(form-init6188456576730631251.clj:1)
	at user$eval5.invoke(form-init6188456576730631251.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unable to resolve symbol: error in this context
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.resolveIn(Compiler.java:7164)
	at clojure.lang.Compiler.resolve(Compiler.java:7108)
	at clojure.lang.Compiler.analyzeSymbol(Compiler.java:7069)
	at clojure.lang.Compiler.analyze(Compiler.java:6648)
	... 73 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unable to resolve symbol: display in this context, compiling:(symbolic_algebra/core.clj:254:7)
	at clojure.lang.Compiler.analyze(Compiler.java:6688)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3766)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$IfExpr$Parser.parse(Compiler.java:2805)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6856)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$MapExpr.parse(Compiler.java:3072)
	at clojure.lang.Compiler.analyze(Compiler.java:6677)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.eval(Compiler.java:6924)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init5751698891452223034.clj:1)
	at user$eval5.invokeStatic(form-init5751698891452223034.clj:1)
	at user$eval5.invoke(form-init5751698891452223034.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unable to resolve symbol: display in this context
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.resolveIn(Compiler.java:7164)
	at clojure.lang.Compiler.resolve(Compiler.java:7108)
	at clojure.lang.Compiler.analyzeSymbol(Compiler.java:7069)
	at clojure.lang.Compiler.analyze(Compiler.java:6648)
	... 73 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init71122107446258049.clj:1:123)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init71122107446258049.clj:1)
	at user$eval5.invoke(form-init71122107446258049.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init6321367301272749577.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init6321367301272749577.clj:1)
	at user$eval5.invoke(form-init6321367301272749577.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: :real, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init1412439109100063902.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: :real
	at clojure.lang.MultiFn.getFn(MultiFn.java:156)
	at clojure.lang.MultiFn.invoke(MultiFn.java:233)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init1412439109100063902.clj:1)
	at user$eval5.invoke(form-init1412439109100063902.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: :real, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init120957663680717378.clj:1:124)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: :real
	at clojure.lang.MultiFn.getFn(MultiFn.java:156)
	at clojure.lang.MultiFn.invoke(MultiFn.java:233)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init120957663680717378.clj:1)
	at user$eval5.invoke(form-init120957663680717378.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init7991135994307232163.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init7991135994307232163.clj:1)
	at user$eval5.invoke(form-init7991135994307232163.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>ls
CHANGELOG.md	README.md	project.clj	resources	target
LICENSE		doc		project.clj~	src		test
:symbolic-algebra>cd src
:src>ls
symbolic_algebra
:src>cd symbcol_algebra
bash: cd: symbcol_algebra: No such file or directory
cd symbolic_algebra
:symbolic_algebra>ls
core.clj	core.clj~
:symbolic_algebra
:symbolic_algebra>git commit core.clj -m "added reduction & polynomials"
fatal: Not a git repository (or any of the parent directories): .git
:symbolic_algebra>git help
usage: git [--version] [--help] [-C <path>] [-c name=value]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Find by binary search the change that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common history
   branch     List, create, or delete branches
   checkout   Switch branches or restore working tree files
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   merge      Join two or more development histories together
   rebase     Forward-port local commits to the updated upstream head
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate (see also: git help workflows)
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a local branch
   push       Update remote refs along with associated objects

'git help -a' and 'git help -g' list available subcommands and some
concept guides. See 'git help <command>' or 'git help <concept>'
to read about a specific subcommand or concept.
:symbolic_algebra>git am help
fatal: Not a git repository (or any of the parent directories): .git
:symbolic_algebra>git am
fatal: Not a git repository (or any of the parent directories): .git
:symbolic_algebra>git hep am
git: 'hep' is not a git command. See 'git --help'.

Did you mean this?
	help
:symbolic_algebra>git help am
WARNING: terminal is not fully functional
-  (press RETURN)
GIT-AM(1)                          Git Manual                          GIT-AM(1)

NAME
       git-am - Apply a series of patches from a mailbox

SYNOPSIS
       git am [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8]
                [--3way] [--interactive] [--committer-date-is-author-date]
                [--ignore-date] [--ignore-space-change | --ignore-whitespace]
                [--whitespace=<option>] [-C<n>] [-p<n>] [--directory=<dir>]
                [--exclude=<path>] [--include=<path>] [--reject] [-q | --quiet]
                [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>]
                [(<mbox> | <Maildir>)...]
       git am (--continue | --skip | --abort)

DESCRIPTION
       Splits mail messages in a mailbox into commit log message, authorship
       information and patches, and applies them to the current branch.

OPTIONS
       (<mbox>|<Maildir>)...
           The list of mailbox files to read patches from. If you do not supply
           this argument, the command reads from the standard input. If you
:
           supply directories, they will be treated as Maildirs.
:

:
       -s, --signoff
:
           Add a Signed-off-by: line to the commit message, using the committer
:
           identity of yourself.
:

:
       -k, --keep
:
           Pass -k flag to git mailinfo (see git-mailinfo(1)).
:

:
       --keep-non-patch
:
           Pass -b flag to git mailinfo (see git-mailinfo(1)).
:

:
       --[no-]keep-cr
:
           With --keep-cr, call git mailsplit (see git-mailsplit(1)) with the
:
           same option, to prevent it from stripping CR at the end of lines.
:
           am.keepcr configuration variable can be used to specify the default
:
           behaviour.  --no-keep-cr is useful to override am.keepcr.
:

:
       -c, --scissors
:
           Remove everything in body before a scissors line (see git-
:
           mailinfo(1)). Can be activated by default using the mailinfo.scissors
:
           configuration variable.
:

:
       --no-scissors
:
           Ignore scissors lines (see git-mailinfo(1)).
:

:
       -m, --message-id
:
           Pass the -m flag to git mailinfo (see git-mailinfo(1)), so that the
:
           Message-ID header is added to the commit message. The am.messageid
:
           configuration variable can be used to specify the default behaviour.
:

:
       --no-message-id
:
           Do not add the Message-ID header to the commit message.
:
           no-message-id is useful to override am.messageid.
:

:
       -q, --quiet
:
           Be quiet. Only print error messages.
:

:
       -u, --utf8
:
           Pass -u flag to git mailinfo (see git-mailinfo(1)). The proposed
:
           commit log message taken from the e-mail is re-coded into UTF-8
:
           encoding (configuration variable i18n.commitencoding can be used to
:
           specify project's preferred encoding if it is not UTF-8).
:

:
           This was optional in prior versions of git, but now it is the
:
           default. You can use --no-utf8 to override this.
:

:
       --no-utf8
:
           Pass -n flag to git mailinfo (see git-mailinfo(1)).
:

:
       -3, --3way
:
           When the patch does not apply cleanly, fall back on 3-way merge if
:
           the patch records the identity of blobs it is supposed to apply to
:
           and we have those blobs available locally.
:

:
       --ignore-space-change, --ignore-whitespace, --whitespace=<option>, -C<n>,
:
       -p<n>, --directory=<dir>, --exclude=<path>, --include=<path>, --reject
:
           These flags are passed to the git apply (see git-apply(1)) program
:
           that applies the patch.
:

:
       --patch-format
:
           By default the command will try to detect the patch format
:
           automatically. This option allows the user to bypass the automatic
:
           detection and specify the patch format that the patch(es) should be
:
           interpreted as. Valid formats are mbox, stgit, stgit-series and hg.
:

:
       -i, --interactive
:
           Run interactively.
:

:
       --committer-date-is-author-date
:
           By default the command records the date from the e-mail message as
:
           the commit author date, and uses the time of commit creation as the
:
           committer date. This allows the user to lie about the committer date
:
           by using the same value as the author date.
:

:
       --ignore-date
:
           By default the command records the date from the e-mail message as
:
           the commit author date, and uses the time of commit creation as the
:
           committer date. This allows the user to lie about the author date by
:
           using the same value as the committer date.
:

:
       --skip
:
           Skip the current patch. This is only meaningful when restarting an
:
           aborted patch.
:

:
       -S[<keyid>], --gpg-sign[=<keyid>]
:
           GPG-sign commits.
:

:
       --continue, -r, --resolved
:
           After a patch failure (e.g. attempting to apply conflicting patch),
:
           the user has applied it by hand and the index file stores the result
:
           of the application. Make a commit using the authorship and commit log
:
           extracted from the e-mail message and the current index file, and
:
           continue.
:

:
       --resolvemsg=<msg>
:
           When a patch failure occurs, <msg> will be printed to the screen
:
           before exiting. This overrides the standard message informing you to
:
           use --continue or --skip to handle the failure. This is solely for
:
           internal use between git rebase and git am.
:

:
       --abort
:
           Restore the original branch and abort the patching operation.
:

:
DISCUSSION
:
       The commit author name is taken from the "From: " line of the message,
:
       and commit author date is taken from the "Date: " line of the message.
:
       The "Subject: " line is used as the title of the commit, after stripping
:
       common prefix "[PATCH <anything>]". The "Subject: " line is supposed to
:
       concisely describe what the commit is about in one line of text.
:

:
       "From: " and "Subject: " lines starting the body override the respective
:
       commit author name and title values taken from the headers.
:

:
       The commit message is formed by the title taken from the "Subject: ", a
:
       blank line and the body of the message up to where the patch begins.
:
       Excess whitespace at the end of each line is automatically stripped.
:

:
       The patch is expected to be inline, directly following the message. Any
:
       line that is of the form:
:

:
       o   three-dashes and end-of-line, or
:

:
       o   a line that begins with "diff -", or
:

:
       o   a line that begins with "Index: "
:

:
       is taken as the beginning of a patch, and the commit log message is
:
       terminated before the first occurrence of such a line.
:

:
       When initially invoking git am, you give it the names of the mailboxes to
:
       process. Upon seeing the first patch that does not apply, it aborts in
:
       the middle. You can recover from this in one of two ways:
:

:
        1. skip the current patch by re-running the command with the --skip
:
           option.
:

:
        2. hand resolve the conflict in the working directory, and update the
:
           index file to bring it into a state that the patch should have
:
           produced. Then run the command with the --continue option.
:

:
       The command refuses to process new mailboxes until the current operation
:
       is finished, so if you decide to start over from scratch, run git am
:
       --abort before running the command with mailbox names.
:

:
       Before any patches are applied, ORIG_HEAD is set to the tip of the
:
       current branch. This is useful if you have problems with multiple
:
       commits, like running git am on the wrong branch or an error in the
:
       commits that is more easily fixed by changing the mailbox (e.g. errors in
:
       the "From:" lines).
:

:
HOOKS
:
       This command can run applypatch-msg, pre-applypatch, and post-applypatch
:
       hooks. See githooks(5) for more information.
:

:
SEE ALSO
:
       git-apply(1).
:

:
GIT
:
       Part of the git(1) suite
:exit

:
Git 2.5.0                          07/27/2015                          GIT-AM(1)
:
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)exit
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)
(END)git 


...skipping...
GIT-AM(1)                          Git Manual                          GIT-AM(1)

NAME
       git-am - Apply a series of patches from a mailbox

SYNOPSIS
       git am [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8]
                [--3way] [--interactive] [--committer-date-is-author-date]
                [--ignore-date] [--ignore-space-change | --ignore-whitespace]
                [--whitespace=<option>] [-C<n>] [-p<n>] [--directory=<dir>]
                [--exclude=<path>] [--include=<path>] [--reject] [-q | --quiet]
                [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>]
                [(<mbox> | <Maildir>)...]
       git am (--continue | --skip | --abort)

DESCRIPTION
       Splits mail messages in a mailbox into commit log message, authorship
       information and patches, and applies them to the current branch.

OPTIONS
       (<mbox>|<Maildir>)...
           The list of mailbox files to read patches from. If you do not supply
           this argument, the command reads from the standard input. If you
           supply directories, they will be treated as Maildirs.
:

:git exit
...skipping...
GIT-AM(1)                          Git Manual                          GIT-AM(1)

NAME
       git-am - Apply a series of patches from a mailbox

SYNOPSIS
       git am [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8]
                [--3way] [--interactive] [--committer-date-is-author-date]
                [--ignore-date] [--ignore-space-change | --ignore-whitespace]
                [--whitespace=<option>] [-C<n>] [-p<n>] [--directory=<dir>]
                [--exclude=<path>] [--include=<path>] [--reject] [-q | --quiet]
                [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>]
                [(<mbox> | <Maildir>)...]
       git am (--continue | --skip | --abort)

DESCRIPTION
       Splits mail messages in a mailbox into commit log message, authorship
       information and patches, and applies them to the current branch.

OPTIONS
       (<mbox>|<Maildir>)...
           The list of mailbox files to read patches from. If you do not supply
           this argument, the command reads from the standard input. If you
           supply directories, they will be treated as Maildirs.
:git help interactive
...skipping...
GIT-AM(1)                          Git Manual                          GIT-AM(1)

NAME
       git-am - Apply a series of patches from a mailbox

SYNOPSIS
       git am [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8]
                [--3way] [--interactive] [--committer-date-is-author-date]
                [--ignore-date] [--ignore-space-change | --ignore-whitespace]
                [--whitespace=<option>] [-C<n>] [-p<n>] [--directory=<dir>]
                [--exclude=<path>] [--include=<path>] [--reject] [-q | --quiet]
                [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>]
                [(<mbox> | <Maildir>)...]
       git am (--continue | --skip | --abort)

DESCRIPTION
       Splits mail messages in a mailbox into commit log message, authorship
       information and patches, and applies them to the current branch.

OPTIONS
       (<mbox>|<Maildir>)...
           The list of mailbox files to read patches from. If you do not supply
           this argument, the command reads from the standard input. If you
...skipping...

                   SUMMARY OF LESS COMMANDS

      Commands marked with * may be preceded by a number, N.
      Notes in parentheses indicate the behavior if N is given.
      A key preceded by a caret indicates the Ctrl key; thus ^K is ctrl-K.

  h  H                 Display this help.
  q  :q  Q  :Q  ZZ     Exit.
 ---------------------------------------------------------------------------

                           MOVING

  e  ^E  j  ^N  CR  *  Forward  one line   (or N lines).
  y  ^Y  k  ^K  ^P  *  Backward one line   (or N lines).
  f  ^F  ^V  SPACE  *  Forward  one window (or N lines).
  b  ^B  ESC-v      *  Backward one window (or N lines).
  z                 *  Forward  one window (and set window to N).
  w                 *  Backward one window (and set window to N).
  ESC-SPACE         *  Forward  one window, but don't stop at end-of-file.
  d  ^D             *  Forward  one half-window (and set half-window to N).
  u  ^U             *  Backward one half-window (and set half-window to N).
  ESC-)  RightArrow *  Left  one half screen width (or N positions).
  ESC-(  LeftArrow  *  Right one half screen width (or N positions).
...skipping...

                   SUMMARY OF LESS COMMANDS

      Commands marked with * may be preceded by a number, N.
      Notes in parentheses indicate the behavior if N is given.
      A key preceded by a caret indicates the Ctrl key; thus ^K is ctrl-K.

  h  H                 Display this help.
  q  :q  Q  :Q  ZZ     Exit.
 ---------------------------------------------------------------------------

                           MOVING

  e  ^E  j  ^N  CR  *  Forward  one line   (or N lines).
  y  ^Y  k  ^K  ^P  *  Backward one line   (or N lines).
  f  ^F  ^V  SPACE  *  Forward  one window (or N lines).
  b  ^B  ESC-v      *  Backward one window (or N lines).
  z                 *  Forward  one window (and set window to N).
  w                 *  Backward one window (and set window to N).
  ESC-SPACE         *  Forward  one window, but don't stop at end-of-file.
  d  ^D             *  Forward  one half-window (and set half-window to N).
  u  ^U             *  Backward one half-window (and set half-window to N).
  ESC-)  RightArrow *  Left  one half screen width (or N positions).
  ESC-(  LeftArrow  *  Right one half screen width (or N positions).
  F                    Forward forever; like "tail -f".
  r  ^R  ^L            Repaint screen.
  R                    Repaint screen, discarding buffered input.
        ---------------------------------------------------
        Default "window" is the screen height.
        Default "half-window" is half of the screen height.
 ---------------------------------------------------------------------------

                          SEARCHING

  /pattern          *  Search forward for (N-th) matching line.
  ?pattern          *  Search backward for (N-th) matching line.
  n                 *  Repeat previous search (for N-th occurrence).
  N                 *  Repeat previous search in reverse direction.
  ESC-n             *  Repeat previous search, spanning files.
  ESC-N             *  Repeat previous search, reverse dir. & spanning files.
  ESC-u                Undo (toggle) search highlighting.
  &pattern          *  Display only matching lines
        ---------------------------------------------------
        A search pattern may be preceded by one or more of:
        ^N or !  Search for NON-matching lines.
        ^E or *  Search multiple files (pass thru END OF FILE).
...skipping...
  ESC-(  LeftArrow  *  Right one half screen width (or N positions).
  F                    Forward forever; like "tail -f".
  r  ^R  ^L            Repaint screen.
  R                    Repaint screen, discarding buffered input.
        ---------------------------------------------------
        Default "window" is the screen height.
        Default "half-window" is half of the screen height.
 ---------------------------------------------------------------------------

                          SEARCHING

  /pattern          *  Search forward for (N-th) matching line.
  ?pattern          *  Search backward for (N-th) matching line.
  n                 *  Repeat previous search (for N-th occurrence).
  N                 *  Repeat previous search in reverse direction.
  ESC-n             *  Repeat previous search, spanning files.
  ESC-N             *  Repeat previous search, reverse dir. & spanning files.
  ESC-u                Undo (toggle) search highlighting.
  &pattern          *  Display only matching lines
        ---------------------------------------------------
        A search pattern may be preceded by one or more of:
        ^N or !  Search for NON-matching lines.
        ^E or *  Search multiple files (pass thru END OF FILE).
        ^F or @  Start search at FIRST file (for /) or last file (for ?).
...skipping...
  F                    Forward forever; like "tail -f".
  r  ^R  ^L            Repaint screen.
  R                    Repaint screen, discarding buffered input.
        ---------------------------------------------------
        Default "window" is the screen height.
        Default "half-window" is half of the screen height.
 ---------------------------------------------------------------------------

                          SEARCHING

  /pattern          *  Search forward for (N-th) matching line.
  ?pattern          *  Search backward for (N-th) matching line.
  n                 *  Repeat previous search (for N-th occurrence).
  N                 *  Repeat previous search in reverse direction.
  ESC-n             *  Repeat previous search, spanning files.
  ESC-N             *  Repeat previous search, reverse dir. & spanning files.
  ESC-u                Undo (toggle) search highlighting.
  &pattern          *  Display only matching lines
        ---------------------------------------------------
        A search pattern may be preceded by one or more of:
        ^N or !  Search for NON-matching lines.
        ^E or *  Search multiple files (pass thru END OF FILE).
        ^F or @  Start search at FIRST file (for /) or last file (for ?).
        ^K       Highlight matches, but don't move (KEEP position).
        ^R       Don't use REGULAR EXPRESSIONS.
HELP -- Press RETURN for more, or q when done
 ---------------------------------------------------------------------------
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
                           JUMPING
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
  g  <  ESC-<       *  Go to first line in file (or line N).
HELP -- Press RETURN for more, or q when done
  G  >  ESC->       *  Go to last line in file (or line N).
HELP -- Press RETURN for more, or q when done
  p  %              *  Go to beginning of file (or N percent into file).
HELP -- Press RETURN for more, or q when done
  t                 *  Go to the (N-th) next tag.
HELP -- Press RETURN for more, or q when done
  T                 *  Go to the (N-th) previous tag.
HELP -- Press RETURN for more, or q when done
  {  (  [           *  Find close bracket } ) ].
HELP -- Press RETURN for more, or q when done
  }  )  ]           *  Find open bracket { ( [.
HELP -- Press RETURN for more, or q when done
  ESC-^F <c1> <c2>  *  Find close bracket <c2>.
HELP -- Press RETURN for more, or q when done
  ESC-^B <c1> <c2>  *  Find open bracket <c1> 
HELP -- Press RETURN for more, or q when done
        ---------------------------------------------------
HELP -- Press RETURN for more, or q when done
        Each "find close bracket" command goes forward to the close bracket 
HELP -- Press RETURN for more, or q when done
          matching the (N-th) open bracket in the top line.
HELP -- Press RETURN for more, or q when done
        Each "find open bracket" command goes backward to the open bracket 
HELP -- Press RETURN for more, or q when done
          matching the (N-th) close bracket in the bottom line.
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
  m<letter>            Mark the current position with <letter>.
HELP -- Press RETURN for more, or q when done
  '<letter>            Go to a previously marked position.
HELP -- Press RETURN for more, or q when done
  ''                   Go to the previous position.
HELP -- Press RETURN for more, or q when done
  ^X^X                 Same as '.
HELP -- Press RETURN for more, or q when done
        ---------------------------------------------------
HELP -- Press RETURN for more, or q when done
        A mark is any upper-case or lower-case letter.
HELP -- Press RETURN for more, or q when done
        Certain marks are predefined:
HELP -- Press RETURN for more, or q when done
             ^  means  beginning of the file
HELP -- Press RETURN for more, or q when done
             $  means  end of the file
HELP -- Press RETURN for more, or q when done
 ---------------------------------------------------------------------------
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
                        CHANGING FILES
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
  :e [file]            Examine a new file.
HELP -- Press RETURN for more, or q when done
  ^X^V                 Same as :e.
HELP -- Press RETURN for more, or q when done
  :n                *  Examine the (N-th) next file from the command line.
HELP -- Press RETURN for more, or q when done
  :p                *  Examine the (N-th) previous file from the command line.
HELP -- Press RETURN for more, or q when done
  :x                *  Examine the first (or N-th) file from the command line.
HELP -- Press RETURN for more, or q when done
  :d                   Delete the current file from the command line list.
HELP -- Press RETURN for more, or q when done
  =  ^G  :f            Print current file name.
HELP -- Press RETURN for more, or q when done
 ---------------------------------------------------------------------------
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
                    MISCELLANEOUS COMMANDS
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
  -<flag>              Toggle a command line option [see OPTIONS below].
HELP -- Press RETURN for more, or q when done
  --<name>             Toggle a command line option, by name.
HELP -- Press RETURN for more, or q when done
  _<flag>              Display the setting of a command line option.
HELP -- Press RETURN for more, or q when done
  __<name>             Display the setting of an option, by name.
HELP -- Press RETURN for more, or q when done
  +cmd                 Execute the less cmd each time a new file is examined.
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
  !command             Execute the shell command with $SHELL.
HELP -- Press RETURN for more, or q when done
  |Xcommand            Pipe file between current pos & mark X to shell command.
HELP -- Press RETURN for more, or q when done
  v                    Edit the current file with $VISUAL or $EDITOR.
HELP -- Press RETURN for more, or q when done
  V                    Print version number of "less".
HELP -- Press RETURN for more, or q when done
 ---------------------------------------------------------------------------
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
                           OPTIONS
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
        Most options may be changed either on the command line,
HELP -- Press RETURN for more, or q when done
        or from within less by using the - or -- command.
HELP -- Press RETURN for more, or q when done
        Options may be given in one of two forms: either a single
HELP -- Press RETURN for more, or q when done
        character preceded by a -, or a name preceded by --.
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
  -?  ........  --help
HELP -- Press RETURN for more, or q when done
                  Display help (from command line).
HELP -- Press RETURN for more, or q when done
  -a  ........  --search-skip-screen
HELP -- Press RETURN for more, or q when done
                  Search skips current screen.
HELP -- Press RETURN for more, or q when done
  -A  ........  --SEARCH-SKIP-SCREEN
HELP -- Press RETURN for more, or q when done
                  Search starts just after target line.
HELP -- Press RETURN for more, or q when done
  -b [N]  ....  --buffers=[N]
HELP -- Press RETURN for more, or q when done
                  Number of buffers.
HELP -- Press RETURN for more, or q when done
  -B  ........  --auto-buffers
HELP -- Press RETURN for more, or q when done
                  Don't automatically allocate buffers for pipes.
HELP -- Press RETURN for more, or q when done
  -c  ........  --clear-screen
HELP -- Press RETURN for more, or q when done
                  Repaint by clearing rather than scrolling.
HELP -- Press RETURN for more, or q when done
  -d  ........  --dumb
HELP -- Press RETURN for more, or q when done
                  Dumb terminal.
HELP -- Press RETURN for more, or q when done
  -D [xn.n]  .  --color=xn.n
HELP -- Press RETURN for more, or q when done
                  Set screen colors. (MS-DOS only)
HELP -- Press RETURN for more, or q when done
  -e  -E  ....  --quit-at-eof  --QUIT-AT-EOF
HELP -- Press RETURN for more, or q when done
                  Quit at end of file.
HELP -- Press RETURN for more, or q when done
  -f  ........  --force
HELP -- Press RETURN for more, or q when done
                  Force open non-regular files.
HELP -- Press RETURN for more, or q when done
  -F  ........  --quit-if-one-screen
HELP -- Press RETURN for more, or q when done
                  Quit if entire file fits on first screen.
HELP -- Press RETURN for more, or q when done
  -g  ........  --hilite-search
HELP -- Press RETURN for more, or q when done
                  Highlight only last match for searches.
HELP -- Press RETURN for more, or q when done
  -G  ........  --HILITE-SEARCH
HELP -- Press RETURN for more, or q when done
                  Don't highlight any matches for searches.
HELP -- Press RETURN for more, or q when done
  -h [N]  ....  --max-back-scroll=[N]
HELP -- Press RETURN for more, or q when done
                  Backward scroll limit.
HELP -- Press RETURN for more, or q when done
  -i  ........  --ignore-case
HELP -- Press RETURN for more, or q when done
                  Ignore case in searches that do not contain uppercase.
HELP -- Press RETURN for more, or q when done
  -I  ........  --IGNORE-CASE
HELP -- Press RETURN for more, or q when done
                  Ignore case in all searches.
HELP -- Press RETURN for more, or q when done
  -j [N]  ....  --jump-target=[N]
HELP -- Press RETURN for more, or q when done
                  Screen position of target lines.
HELP -- Press RETURN for more, or q when done
  -J  ........  --status-column
HELP -- Press RETURN for more, or q when done
                  Display a status column at left edge of screen.
HELP -- Press RETURN for more, or q when done
  -k [file]  .  --lesskey-file=[file]
HELP -- Press RETURN for more, or q when done
                  Use a lesskey file.
HELP -- Press RETURN for more, or q when done
  -K            --quit-on-intr
HELP -- Press RETURN for more, or q when done
                  Exit less in response to ctrl-C.
HELP -- Press RETURN for more, or q when done
  -L  ........  --no-lessopen
HELP -- Press RETURN for more, or q when done
                  Ignore the LESSOPEN environment variable.
HELP -- Press RETURN for more, or q when done
  -m  -M  ....  --long-prompt  --LONG-PROMPT
HELP -- Press RETURN for more, or q when done
                  Set prompt style.
HELP -- Press RETURN for more, or q when done
  -n  -N  ....  --line-numbers  --LINE-NUMBERS
HELP -- Press RETURN for more, or q when done
                  Don't use line numbers.
HELP -- Press RETURN for more, or q when done
  -o [file]  .  --log-file=[file]
HELP -- Press RETURN for more, or q when done
                  Copy to log file (standard input only).
HELP -- Press RETURN for more, or q when done
  -O [file]  .  --LOG-FILE=[file]
HELP -- Press RETURN for more, or q when done
                  Copy to log file (unconditionally overwrite).
HELP -- Press RETURN for more, or q when done
  -p [pattern]  --pattern=[pattern]
HELP -- Press RETURN for more, or q when done
                  Start at pattern (from command line).
HELP -- Press RETURN for more, or q when done
  -P [prompt]   --prompt=[prompt]
HELP -- Press RETURN for more, or q when done
                  Define new prompt.
HELP -- Press RETURN for more, or q when done
  -q  -Q  ....  --quiet  --QUIET  --silent --SILENT
HELP -- Press RETURN for more, or q when done
                  Quiet the terminal bell.
HELP -- Press RETURN for more, or q when done
  -r  -R  ....  --raw-control-chars  --RAW-CONTROL-CHARS
HELP -- Press RETURN for more, or q when done
                  Output "raw" control characters.
HELP -- Press RETURN for more, or q when done
  -s  ........  --squeeze-blank-lines
HELP -- Press RETURN for more, or q when done
                  Squeeze multiple blank lines.
HELP -- Press RETURN for more, or q when done
  -S  ........  --chop-long-lines
HELP -- Press RETURN for more, or q when done
                  Chop (truncate) long lines rather than wrapping.
HELP -- Press RETURN for more, or q when done
  -t [tag]  ..  --tag=[tag]
HELP -- Press RETURN for more, or q when done
                  Find a tag.
HELP -- Press RETURN for more, or q when done
  -T [tagsfile] --tag-file=[tagsfile]
HELP -- Press RETURN for more, or q when done
                  Use an alternate tags file.
HELP -- Press RETURN for more, or q when done
  -u  -U  ....  --underline-special  --UNDERLINE-SPECIAL
HELP -- Press RETURN for more, or q when done
                  Change handling of backspaces.
HELP -- Press RETURN for more, or q when done
  -V  ........  --version
HELP -- Press RETURN for more, or q when done
                  Display the version number of "less".
HELP -- Press RETURN for more, or q when done
  -w  ........  --hilite-unread
HELP -- Press RETURN for more, or q when done
                  Highlight first new line after forward-screen.
HELP -- Press RETURN for more, or q when done
  -W  ........  --HILITE-UNREAD
HELP -- Press RETURN for more, or q when done
                  Highlight first new line after any forward movement.
HELP -- Press RETURN for more, or q when done
  -x [N[,...]]  --tabs=[N[,...]]
HELP -- Press RETURN for more, or q when done
                  Set tab stops.
HELP -- Press RETURN for more, or q when done
  -X  ........  --no-init
HELP -- Press RETURN for more, or q when done
                  Don't use termcap init/deinit strings.
HELP -- Press RETURN for more, or q when done
  -y [N]  ....  --max-forw-scroll=[N]
HELP -- Press RETURN for more, or q when done

                  Forward scroll limit.
  -z [N]  ....  --window=[N]
HELP -- Press RETURN for more, or q when done
                  Set size of window.
HELP -- Press RETURN for more, or q when done
  -" [c[c]]  .  --quotes=[c[c]]
HELP -- Press RETURN for more, or q when done
                  Set shell quote characters.
HELP -- Press RETURN for more, or q when done
  -~  ........  --tilde
HELP -- Press RETURN for more, or q when done
                  Don't display tildes after end of file.
HELP -- Press RETURN for more, or q when done
  -# [N]  ....  --shift=[N]
HELP -- Press RETURN for more, or q when done
                  Horizontal scroll amount (0 = one half screen width)
HELP -- Press RETURN for more, or q when done
      ........  --no-keypad
HELP -- Press RETURN for more, or q when done
                  Don't send termcap keypad init/deinit strings.
HELP -- Press RETURN for more, or q when done
      ........  --follow-name
HELP -- Press RETURN for more, or q when done
                  The F command changes files if the input file is renamed.
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
 ---------------------------------------------------------------------------
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
                          LINE EDITING
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
        These keys can be used to edit text being entered 
HELP -- Press RETURN for more, or q when done
        on the "command line" at the bottom of the screen.
HELP -- Press RETURN for more, or q when done

HELP -- Press RETURN for more, or q when done
 RightArrow                       ESC-l     Move cursor right one character.
HELP -- Press RETURN for more, or q when done
 LeftArrow                        ESC-h     Move cursor left one character.
HELP -- Press RETURN for more, or q when done
 ctrl-RightArrow  ESC-RightArrow  ESC-w     Move cursor right one word.
HELP -- Press RETURN for more, or q when done
 ctrl-LeftArrow   ESC-LeftArrow   ESC-b     Move cursor left one word.
HELP -- Press RETURN for more, or q when done
 HOME                             ESC-0     Move cursor to start of line.
HELP -- Press RETURN for more, or q when done
 END                              ESC-$     Move cursor to end of line.
HELP -- Press RETURN for more, or q when done
 BACKSPACE                                  Delete char to left of cursor.
HELP -- Press RETURN for more, or q when done
 DELETE                           ESC-x     Delete char under cursor.
HELP -- Press RETURN for more, or q when done
 ctrl-BACKSPACE   ESC-BACKSPACE             Delete word to left of cursor.
HELP -- Press RETURN for more, or q when done
 ctrl-DELETE      ESC-DELETE      ESC-X     Delete word under cursor.
HELP -- Press RETURN for more, or q when done
 ctrl-U           ESC (MS-DOS only)         Delete entire line.
HELP -- Press RETURN for more, or q when done
 UpArrow                          ESC-k     Retrieve previous command line.
HELP -- Press RETURN for more, or q when done
 DownArrow                        ESC-j     Retrieve next command line.
HELP -- Press RETURN for more, or q when done
 TAB                                        Complete filename & cycle.
HELP -- Press RETURN for more, or q when done
 SHIFT-TAB                        ESC-TAB   Complete filename & reverse cycle.
HELP -- Press RETURN for more, or q when done
 ctrl-L                                     Complete filename, list all.
HELP -- Press RETURN for more, or q when done

HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when done
HELP -- END -- Press g to see it again, or q when doneq
...skipping...
GIT-AM(1)                          Git Manual                          GIT-AM(1)

NAME
       git-am - Apply a series of patches from a mailbox

SYNOPSIS
       git am [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8]
                [--3way] [--interactive] [--committer-date-is-author-date]
                [--ignore-date] [--ignore-space-change | --ignore-whitespace]
                [--whitespace=<option>] [-C<n>] [-p<n>] [--directory=<dir>]
                [--exclude=<path>] [--include=<path>] [--reject] [-q | --quiet]
                [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>]
                [(<mbox> | <Maildir>)...]
       git am (--continue | --skip | --abort)

DESCRIPTION
       Splits mail messages in a mailbox into commit log message, authorship
       information and patches, and applies them to the current branch.

OPTIONS
       (<mbox>|<Maildir>)...
           The list of mailbox files to read patches from. If you do not supply
           this argument, the command reads from the standard input. If you
           supply directories, they will be treated as Maildirs.
:q
:symbolic_algebra>:symbolic_algebra>q
bash: q: command not found
:symbolic_algebra>git init
Initialized empty Git repository in /Users/sophiagold/Desktop/Clojure/symbolic-algebra/src/symbolic_algebra/.git/
:symbolic_algebra>git add core.clj
:symbolic_algebra>git commit -m "added type reduction & basic polynomial support"
[master (root-commit) 0fb97cf] added type reduction & basic polynomial support
 1 file changed, 262 insertions(+)
 create mode 100644 core.clj
:symbolic_algebra>git remote add origin https://github.com/Sophia-Gold/symbolic-algebra.clj.git
:symbolic_algebra>git push -u origin master
To https://github.com/Sophia-Gold/symbolic-algebra.clj.git
 ! [rejected]        master -> master (fetch first)
error: failed to push some refs to 'https://github.com/Sophia-Gold/symbolic-algebra.clj.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
:symbolic_algebra>git push -f origin master
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 1.77 KiB | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/Sophia-Gold/symbolic-algebra.clj.git
 + c40221e...0fb97cf master -> master (forced update)
:symbolic_algebra>git ls-files -d | xargs git checkout --
:symbolic_algebra>ls
core.clj	core.clj~
:symbolic_algebra>git ls-files
core.clj
:symbolic_algebra>git log --diff-filter=D --summary
WARNING: terminal is not fully functional
-  (press RETURN)
:symbolic_algebra>git log
WARNING: terminal is not fully functional
-  (press RETURN)
commit 0fb97cf3b79d20eb489e8c0885b3bfb89b4ef6a4
Author: Sophia Gold <sophiagoldnyc@gmail.com>
Date:   Mon Sep 26 03:35:17 2016 -0400

    added type reduction & basic polynomial support
:symbolic_algebra>git fsck
Checking object directories: 100% (256/256), done.
:symbolic_algebra>git fsck help
Checking object directories: 100% (256/256), done.
error: invalid parameter: expected sha1, got 'help'
:symbolic_algebra>git help fsck
WARNING: terminal is not fully functional
-  (press RETURN)
GIT-FSCK(1)                        Git Manual                        GIT-FSCK(1)

NAME
       git-fsck - Verifies the connectivity and validity of the objects in the
       database

SYNOPSIS
       git fsck [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]
                [--[no-]full] [--strict] [--verbose] [--lost-found]
                [--[no-]dangling] [--[no-]progress] [<object>*]

DESCRIPTION
       Verifies the connectivity and validity of the objects in the database.

OPTIONS
       <object>
           An object to treat as the head of an unreachability trace.

           If no objects are given, git fsck defaults to using the index file,
           all SHA-1 references in refs namespace, and all reflogs (unless
           --no-reflogs is given) as heads.

       --unreachable
:
           Print out objects that exist but that aren't reachable from any of
:
           the reference nodes.
:

:
       --[no-]dangling
:
           Print objects that exist but that are never directly used (default).
:
           --no-dangling can be used to omit this information from the output.
:

:
       --root
:
           Report root nodes.
:

:
       --tags
:
           Report tags.
:

:
       --cache
:
           Consider any object recorded in the index also as a head node for an
:
           unreachability trace.
:

:
       --no-reflogs
:
           Do not consider commits that are referenced only by an entry in a
:
           reflog to be reachable. This option is meant only to search for
:
           commits that used to be in a ref, but now aren't, but are still in
:
           that corresponding reflog.
:

:
       --full
:
           Check not just objects in GIT_OBJECT_DIRECTORY ($GIT_DIR/objects),
:
           but also the ones found in alternate object pools listed in
:
           GIT_ALTERNATE_OBJECT_DIRECTORIES or $GIT_DIR/objects/info/alternates,
:
           and in packed Git archives found in $GIT_DIR/objects/pack and
:
           corresponding pack subdirectories in alternate object pools. This is
:
           now default; you can turn it off with --no-full.
:

:
       --strict
:
           Enable more strict checking, namely to catch a file mode recorded
:
           with g+w bit set, which was created by older versions of Git.
:
           Existing repositories, including the Linux kernel, Git itself, and
:
           sparse repository have old objects that triggers this check, but it
:
           is recommended to check new projects with this flag.
:

:
       --verbose
:
           Be chatty.
:

:
       --lost-found
:
           Write dangling objects into .git/lost-found/commit/ or
:
           .git/lost-found/other/, depending on type. If the object is a blob,
:
           the contents are written into the file, rather than its object name.
:

:
       --[no-]progress
:
           Progress status is reported on the standard error stream by default
:
           when it is attached to a terminal, unless --no-progress or --verbose
:
           is specified. --progress forces progress status even if the standard
:
           error stream is not directed to a terminal.
:

:
DISCUSSION
:
       git-fsck tests SHA-1 and general object sanity, and it does full tracking
:
       of the resulting reachability and everything else. It prints out any
:
       corruption it finds (missing or bad objects), and if you use the
:
       --unreachable flag it will also print out objects that exist but that
:
       aren't reachable from any of the specified head nodes (or the default
:
       set, as mentioned above).
:

:
       Any corrupt objects you will have to find in backups or other archives
:
       (i.e., you can just remove them and do an rsync with some other site in
:
       the hopes that somebody else has the object you have corrupted).
:

:
EXTRACTED DIAGNOSTICS
:
       expect dangling commits - potential heads - due to lack of head
:
       information
:
           You haven't specified any nodes as heads so it won't be possible to
:
           differentiate between un-parented commits and root nodes.
:

:
       missing sha1 directory <dir>
:
           The directory holding the sha1 objects is missing.
:

:
       unreachable <type> <object>
:
           The <type> object <object>, isn't actually referred to directly or
:
           indirectly in any of the trees or commits seen. This can mean that
:
           there's another root node that you're not specifying or that the tree
:
           is corrupt. If you haven't missed a root node then you might as well
:
           delete unreachable nodes since they can't be used.
:

:
       missing <type> <object>
:
           The <type> object <object>, is referred to but isn't present in the
:
           database.
:

:
       dangling <type> <object>
:
           The <type> object <object>, is present in the database but never
:
           directly used. A dangling commit could be a root node.
:

:
       sha1 mismatch <object>
:
           The database has an object who's sha1 doesn't match the database
:
           value. This indicates a serious data integrity problem.
:

:
ENVIRONMENT VARIABLES
:
       GIT_OBJECT_DIRECTORY
:
           used to specify the object database root (usually $GIT_DIR/objects)
:

:
       GIT_INDEX_FILE
:
           used to specify the index file of the index
:

:
       GIT_ALTERNATE_OBJECT_DIRECTORIES
:
           used to specify additional object database roots (usually unset)
:

:
GIT
:
       Part of the git(1) suite
:

:
Git 2.5.0                          07/27/2015                        GIT-FSCK(1)
:
(END)
(END)
(END)q
:symbolic_algebra>:symbolic_algebra>z
bash: z: command not found
:symbolic_algebra>git reflog
WARNING: terminal is not fully functional
-  (press RETURN)
0fb97cf HEAD@{0}: commit (initial): added type reduction & basic polynomial support
:symbolic_algebra>
:symbolic_algebra>git help
usage: git [--version] [--help] [-C <path>] [-c name=value]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Find by binary search the change that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common history
   branch     List, create, or delete branches
   checkout   Switch branches or restore working tree files
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   merge      Join two or more development histories together
   rebase     Forward-port local commits to the updated upstream head
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate (see also: git help workflows)
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a local branch
   push       Update remote refs along with associated objects

'git help -a' and 'git help -g' list available subcommands and some
concept guides. See 'git help <command>' or 'git help <concept>'
to read about a specific subcommand or concept.
:symbolic_algebra>git reset
:symbolic_algebra>ls
core.clj	core.clj~
:symbolic_algebra>git reset origin master
fatal: ambiguous argument 'origin': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git <command> [<revision>...] -- [<file>...]'
:symbolic_algebra>git reflog
WARNING: terminal is not fully functional
-  (press RETURN)
0fb97cf HEAD@{0}: commit (initial): added type reduction & basic polynomial support
:symbolic_algebra>git reset 0fb97cf
:symbolic_algebra>git cat-file -p master^{tree}
bash: cat-file: command not found
:symbolic_algebra>git cat-file -p master^{tree}
100644 blob 5805b6af2975432e504f18576ab6ace12f85c5ba	core.clj
:symbolic_algebra>
:symbolic_algebra>git cat-file -p master^{tree}
100644 blob 5805b6af2975432e504f18576ab6ace12f85c5ba	core.clj
:symbolic_algebra>git cat-file -p master^{tree}
100644 blob 5805b6af2975432e504f18576ab6ace12f85c5ba	core.clj
:symbolic_algebra>git log
WARNING: terminal is not fully functional
-  (press RETURN)
commit 0fb97cf3b79d20eb489e8c0885b3bfb89b4ef6a4
Author: Sophia Gold <sophiagoldnyc@gmail.com>
Date:   Mon Sep 26 03:35:17 2016 -0400

    added type reduction & basic polynomial support
:symbolic_algebra>git diff
WARNING: terminal is not fully functional
-  (press RETURN)
:symbolic_algebra>
:symbolic_algebra>git diff
WARNING: terminal is not fully functional
-  (press RETURN)
:symbolic_algebra>git diff origin master
fatal: ambiguous argument 'origin': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git <command> [<revision>...] -- [<file>...]'
:symbolic_algebra>git reset help
fatal: ambiguous argument 'help': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git <command> [<revision>...] -- [<file>...]'
:symbolic_algebra>git help reset
WARNING: terminal is not fully functional
-  (press RETURN)
GIT-RESET(1)                       Git Manual                       GIT-RESET(1)

NAME
       git-reset - Reset current HEAD to the specified state

SYNOPSIS
       git reset [-q] [<tree-ish>] [--] <paths>...
       git reset (--patch | -p) [<tree-ish>] [--] [<paths>...]
       git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]

DESCRIPTION
       In the first and second form, copy entries from <tree-ish> to the index.
       In the third form, set the current branch head (HEAD) to <commit>,
       optionally modifying index and working tree to match. The
       <tree-ish>/<commit> defaults to HEAD in all forms.

       git reset [-q] [<tree-ish>] [--] <paths>...
           This form resets the index entries for all <paths> to their state at
           <tree-ish>. (It does not affect the working tree or the current
           branch.)

           This means that git reset <paths> is the opposite of git add <paths>.

:q
:symbolic_algebra>:symbolic_algebra>git reset --hard
HEAD is now at 0fb97cf added type reduction & basic polynomial support
:symbolic_algebra>git reset --hard
HEAD is now at 0fb97cf added type reduction & basic polynomial support
:symbolic_algebra>git reset --merge
:symbolic_algebra>git log
WARNING: terminal is not fully functional
-  (press RETURN)
commit 0fb97cf3b79d20eb489e8c0885b3bfb89b4ef6a4
Author: Sophia Gold <sophiagoldnyc@gmail.com>
Date:   Mon Sep 26 03:35:17 2016 -0400

    added type reduction & basic polynomial support
:symbolic_algebra>git reset -0400 
error: unknown switch `0'
usage: git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [<commit>]
   or: git reset [-q] <tree-ish> [--] <paths>...
   or: git reset --patch [<tree-ish>] [--] [<paths>...]

    -q, --quiet           be quiet, only report errors
    --mixed               reset HEAD and index
    --soft                reset only HEAD
    --hard                reset HEAD, index and working tree
    --merge               reset HEAD, index and working tree
    --keep                reset HEAD but keep local changes
    -p, --patch           select hunks interactively
    -N, --intent-to-add   record only the fact that removed paths will be added later

:symbolic_algebra>git reset -0400 --hard
error: unknown switch `0'
usage: git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [<commit>]
   or: git reset [-q] <tree-ish> [--] <paths>...
   or: git reset --patch [<tree-ish>] [--] [<paths>...]

    -q, --quiet           be quiet, only report errors
    --mixed               reset HEAD and index
    --soft                reset only HEAD
    --hard                reset HEAD, index and working tree
    --merge               reset HEAD, index and working tree
    --keep                reset HEAD but keep local changes
    -p, --patch           select hunks interactively
    -N, --intent-to-add   record only the fact that removed paths will be added later

:symbolic_algebra>git reset origin master --hard
fatal: ambiguous argument 'origin': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git <command> [<revision>...] -- [<file>...]'
:symbolic_algebra>git reset core.clj
:symbolic_algebra>git push origin master
Everything up-to-date
:symbolic_algebra>cd ../..
:symbolic-algebra>ls
CHANGELOG.md	README.md	project.clj	resources	target
LICENSE		doc		project.clj~	src		test
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init546167015387391901.clj:1:124)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:77)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:178)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init546167015387391901.clj:1)
	at user$eval5.invoke(form-init546167015387391901.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.ClassCastException: java.lang.Class cannot be cast to clojure.lang.IFn, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init5691811328038672086.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.ClassCastException: java.lang.Class cannot be cast to clojure.lang.IFn
	at symbolic_algebra.core$eval106$fn__107.doInvoke(core.clj:18)
	at clojure.lang.RestFn.invoke(RestFn.java:423)
	at clojure.lang.MultiFn.invoke(MultiFn.java:233)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init5691811328038672086.clj:1)
	at user$eval5.invoke(form-init5691811328038672086.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: class java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init8408137176068328886.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: class java.lang.Class
	at clojure.lang.MultiFn.getFn(MultiFn.java:156)
	at clojure.lang.MultiFn.invoke(MultiFn.java:233)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init8408137176068328886.clj:1)
	at user$eval5.invoke(form-init8408137176068328886.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.ClassCastException: java.lang.Class cannot be cast to clojure.lang.IFn, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init7968261597687801365.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.ClassCastException: java.lang.Class cannot be cast to clojure.lang.IFn
	at symbolic_algebra.core$eval106$fn__107.doInvoke(core.clj:17)
	at clojure.lang.RestFn.invoke(RestFn.java:423)
	at clojure.lang.MultiFn.invoke(MultiFn.java:233)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:179)
	at symbolic_algebra.core$_main.invoke(core.clj:176)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init7968261597687801365.clj:1)
	at user$eval5.invoke(form-init7968261597687801365.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: [java.lang.Class java.lang.Long], compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init7525431312644770342.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: [java.lang.Class java.lang.Long]
	at clojure.lang.MultiFn.getFn(MultiFn.java:156)
	at clojure.lang.MultiFn.invoke(MultiFn.java:233)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:181)
	at symbolic_algebra.core$_main.invoke(core.clj:178)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init7525431312644770342.clj:1)
	at user$eval5.invoke(form-init7525431312644770342.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein ru'ru' is not a task. See 'lein help'.
n

Did you mean this?
         run
:symbolic-algebra>bash: n: command not found
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unmatched delimiter: ), compiling:(symbolic_algebra/core.clj:19:26)
	at clojure.lang.Compiler.load(Compiler.java:7386)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init5678190588942581538.clj:1)
	at user$eval5.invokeStatic(form-init5678190588942581538.clj:1)
	at user$eval5.invoke(form-init5678190588942581538.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unmatched delimiter: )
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.LispReader$UnmatchedDelimiterReader.invoke(LispReader.java:1176)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$VectorReader.invoke(LispReader.java:1150)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.read(LispReader.java:196)
	at clojure.lang.Compiler.load(Compiler.java:7374)
	... 42 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Unmatched delimiter: ), compiling:(symbolic_algebra/core.clj:19:26)
	at clojure.lang.Compiler.load(Compiler.java:7386)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init2453753956556438301.clj:1)
	at user$eval5.invokeStatic(form-init2453753956556438301.clj:1)
	at user$eval5.invoke(form-init2453753956556438301.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Unmatched delimiter: )
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.LispReader$UnmatchedDelimiterReader.invoke(LispReader.java:1176)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$VectorReader.invoke(LispReader.java:1150)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.readDelimitedList(LispReader.java:1200)
	at clojure.lang.LispReader$ListReader.invoke(LispReader.java:1049)
	at clojure.lang.LispReader.read(LispReader.java:263)
	at clojure.lang.LispReader.read(LispReader.java:196)
	at clojure.lang.Compiler.load(Compiler.java:7374)
	... 42 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: [java.lang.Class java.lang.Long], compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init5725401953660932112.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: [java.lang.Class java.lang.Long]
	at clojure.lang.MultiFn.getFn(MultiFn.java:156)
	at clojure.lang.MultiFn.invoke(MultiFn.java:233)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:181)
	at symbolic_algebra.core$_main.invoke(core.clj:178)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init5725401953660932112.clj:1)
	at user$eval5.invoke(form-init5725401953660932112.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Expecting var, but Real is mapped to class symbolic_algebra.core.Real, compiling:(symbolic_algebra/core.clj:181:11)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6875)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6856)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.access$300(Compiler.java:38)
	at clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:589)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler.eval(Compiler.java:6931)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init8992197312314444789.clj:1)
	at user$eval5.invokeStatic(form-init8992197312314444789.clj:1)
	at user$eval5.invoke(form-init8992197312314444789.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Expecting var, but Real is mapped to class symbolic_algebra.core.Real
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.lookupVar(Compiler.java:7237)
	at clojure.lang.Compiler.isMacro(Compiler.java:6716)
	at clojure.lang.Compiler.macroexpand1(Compiler.java:6771)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6854)
	... 70 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Expecting var, but Real is mapped to class symbolic_algebra.core.Real, compiling:(symbolic_algebra/core.clj:182:11)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6875)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6856)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.access$300(Compiler.java:38)
	at clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:589)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler.eval(Compiler.java:6931)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init6031264115646189300.clj:1)
	at user$eval5.invokeStatic(form-init6031264115646189300.clj:1)
	at user$eval5.invoke(form-init6031264115646189300.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Expecting var, but Real is mapped to class symbolic_algebra.core.Real
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.lookupVar(Compiler.java:7237)
	at clojure.lang.Compiler.isMacro(Compiler.java:6716)
	at clojure.lang.Compiler.macroexpand1(Compiler.java:6771)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6854)
	... 70 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.RuntimeException: Expecting var, but Real is mapped to class symbolic_algebra.core.Real, compiling:(symbolic_algebra/core.clj:182:11)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6875)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3834)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6870)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:6001)
	at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5380)
	at clojure.lang.Compiler$FnExpr.parse(Compiler.java:3972)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6866)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6856)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.access$300(Compiler.java:38)
	at clojure.lang.Compiler$DefExpr$Parser.parse(Compiler.java:589)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6868)
	at clojure.lang.Compiler.analyze(Compiler.java:6669)
	at clojure.lang.Compiler.analyze(Compiler.java:6625)
	at clojure.lang.Compiler.eval(Compiler.java:6931)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.RT.loadResourceScript(RT.java:372)
	at clojure.lang.RT.loadResourceScript(RT.java:363)
	at clojure.lang.RT.load(RT.java:453)
	at clojure.lang.RT.load(RT.java:419)
	at clojure.core$load$fn__5677.invoke(core.clj:5893)
	at clojure.core$load.invokeStatic(core.clj:5892)
	at clojure.core$load.doInvoke(core.clj:5876)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5697)
	at clojure.core$load_one.invoke(core.clj:5692)
	at clojure.core$load_lib$fn__5626.invoke(core.clj:5737)
	at clojure.core$load_lib.invokeStatic(core.clj:5736)
	at clojure.core$load_lib.doInvoke(core.clj:5717)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$load_libs.invokeStatic(core.clj:5774)
	at clojure.core$load_libs.doInvoke(core.clj:5758)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:648)
	at clojure.core$require.invokeStatic(core.clj:5796)
	at clojure.core$require.doInvoke(core.clj:5796)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval5$fn__7.invoke(form-init235580926410128606.clj:1)
	at user$eval5.invokeStatic(form-init235580926410128606.clj:1)
	at user$eval5.invoke(form-init235580926410128606.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: Expecting var, but Real is mapped to class symbolic_algebra.core.Real
	at clojure.lang.Util.runtimeException(Util.java:221)
	at clojure.lang.Compiler.lookupVar(Compiler.java:7237)
	at clojure.lang.Compiler.isMacro(Compiler.java:6716)
	at clojure.lang.Compiler.macroexpand1(Compiler.java:6771)
	at clojure.lang.Compiler.analyzeSeq(Compiler.java:6854)
	... 70 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init6363185141721134975.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:80)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:181)
	at symbolic_algebra.core$_main.invoke(core.clj:179)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init6363185141721134975.clj:1)
	at user$eval5.invoke(form-init6363185141721134975.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init8632167393717993226.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:80)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:181)
	at symbolic_algebra.core$_main.invoke(core.clj:179)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init8632167393717993226.clj:1)
	at user$eval5.invoke(form-init8632167393717993226.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: :Real, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init3728765159253668798.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: :Real
	at clojure.lang.MultiFn.getFn(MultiFn.java:156)
	at clojure.lang.MultiFn.invoke(MultiFn.java:233)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:182)
	at symbolic_algebra.core$_main.invoke(core.clj:179)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init3728765159253668798.clj:1)
	at user$eval5.invoke(form-init3728765159253668798.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: 1, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init9098319389888631264.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No method in multimethod 'make' for dispatch value: 1
	at clojure.lang.MultiFn.getFn(MultiFn.java:156)
	at clojure.lang.MultiFn.invoke(MultiFn.java:233)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:182)
	at symbolic_algebra.core$_main.invoke(core.clj:179)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init9098319389888631264.clj:1)
	at user$eval5.invoke(form-init9098319389888631264.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run
Exception in thread "main" java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class, compiling:(/private/var/folders/74/7ldlw7fs06d8vy6rdcck8y040000gp/T/form-init2400020593560274385.clj:1:125)
	at clojure.lang.Compiler.load(Compiler.java:7391)
	at clojure.lang.Compiler.loadFile(Compiler.java:7317)
	at clojure.main$load_script.invokeStatic(main.clj:275)
	at clojure.main$init_opt.invokeStatic(main.clj:277)
	at clojure.main$init_opt.invoke(main.clj:277)
	at clojure.main$initialize.invokeStatic(main.clj:308)
	at clojure.main$null_opt.invokeStatic(main.clj:342)
	at clojure.main$null_opt.invoke(main.clj:339)
	at clojure.main$main.invokeStatic(main.clj:421)
	at clojure.main$main.doInvoke(main.clj:384)
	at clojure.lang.RestFn.invoke(RestFn.java:421)
	at clojure.lang.Var.invoke(Var.java:383)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.Var.applyTo(Var.java:700)
	at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: No implementation of method: :add of protocol: #'symbolic-algebra.core/Algebra found for class: java.lang.Class
	at clojure.core$_cache_protocol_fn.invokeStatic(core_deftype.clj:568)
	at clojure.core$_cache_protocol_fn.invoke(core_deftype.clj:560)
	at symbolic_algebra.core$eval154$fn__168$G__137__175.invoke(core.clj:80)
	at symbolic_algebra.core$_main.invokeStatic(core.clj:181)
	at symbolic_algebra.core$_main.invoke(core.clj:179)
	at clojure.lang.Var.invoke(Var.java:375)
	at user$eval5.invokeStatic(form-init2400020593560274385.clj:1)
	at user$eval5.invoke(form-init2400020593560274385.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:6927)
	at clojure.lang.Compiler.eval(Compiler.java:6917)
	at clojure.lang.Compiler.load(Compiler.java:7379)
	... 14 more
:symbolic-algebra>lein run